<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="./noble-secp256k1.js"></script>


<script>
    const HEX_LENGTH = 64;
    const MAX_PRIVATE_KEY = BigInt("115792089237316195423570985008687907852837564279074904382605163141518161494336")

    function SHA256HexToByteArray(a)
    {
        return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(a)).toString()
    }

    function RIPEMD160HexToByteArray(a)
    {
        return CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(a)).toString()
    }

    function BytesToHex(byteArray) {
        return Array.from(byteArray, function(byte) 
        {
            return ('0' + (byte & 0xFF).toString(16)).slice(-2);
        }).join('')
    }

    function HexToBytes(hexString) {
    if (hexString.length % 2 !== 0) {
        throw "Must have an even number of hex digits to convert to bytes";
    }/* w w w.  jav  a2 s .  c o  m*/
    var numBytes = hexString.length / 2;
    var byteArray = new Uint8Array(numBytes);
    for (var i=0; i<numBytes; i++) {
        byteArray[i] = parseInt(hexString.substr(i*2, 2), 16);
    }
    return byteArray;
}

    function Base58Encode(hex_number) {
    const base58 = [1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
    var num = BigInt('0x' + hex_number);
    const fifty8 = BigInt(58);
    var remainder;
    var b58_encoded_buffer = '';
    while (num > 0) {
        remainder = num % fifty8;
        b58_encoded_buffer = base58[remainder] + b58_encoded_buffer;
        num = num/BigInt(58);
    }
    while ( hex_number.match(/^00/) ){
        b58_encoded_buffer = '1' + b58_encoded_buffer;
        hex_number = hex_number.substring(2);
    }
    return b58_encoded_buffer;
}

function Base58DecodeToHex(
    S,            //Base58 encoded string input
    A="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"             //Base58 characters (i.e. "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
) {
    var d = [],   //the array for storing the stream of decoded bytes
        b = [],   //the result byte array that will be returned
        i,        //the iterator variable for the base58 string
        j,        //the iterator variable for the byte array (d)
        c,        //the carry amount variable that is used to overflow from the current byte to the next byte
        n;        //a temporary placeholder variable for the current byte
    for(i in S) { //loop through each base58 character in the input string
        j = 0,                             //reset the byte iterator
        c = A.indexOf( S[i] );             //set the initial carry amount equal to the current base58 digit
        if(c < 0)                          //see if the base58 digit lookup is invalid (-1)
            return undefined;              //if invalid base58 digit, bail out and return undefined
        c || b.length ^ i ? i : b.push(0); //prepend the result array with a zero if the base58 digit is zero and non-zero characters haven't been seen yet (to ensure correct decode length)
        while(j in d || c) {               //start looping through the bytes until there are no more bytes and no carry amount
            n = d[j];                      //set the placeholder for the current byte
            n = n ? n * 58 + c : c;        //shift the current byte 58 units and add the carry amount (or just add the carry amount if this is a new byte)
            c = n >> 8;                    //find the new carry amount (1-byte shift of current byte value)
            d[j] = n % 256;                //reset the current byte to the remainder (the carry amount will pass on the overflow)
            j++                            //iterate to the next byte
        }
    }
    while(j--)               //since the byte array is backwards, loop through it in reverse order
        b.push( d[j] );      //append each byte to the result
    return BytesToHex(new Uint8Array(b))
}
    function _GetHexFromPrivateKey(key)
    {
        let decoded = Base58DecodeToHex(key)
        let hexWithoutChecksum = decoded.substr(0, decoded.length-8)
        let hexWithoutPrefix = hexWithoutChecksum.substr(2, hexWithoutChecksum.length-1)

        let formattedHex = _FormatHexStringLength(hexWithoutPrefix)
        return formattedHex;
    }

    function _FormatHexStringLength(s)
    {
        if (s.length == HEX_LENGTH)
            return s

        let trailingZeroes = '';
        let diff = HEX_LENGTH - s.length;

        while (trailingZeroes.length < diff)
        {
            trailingZeroes += '0';
        }
        
        return trailingZeroes + s;
    }

    function _PrivateKeyAndVersionToBitcoinKey(privateKeyAndVersion)
    {
        var firstSHA = SHA256HexToByteArray(privateKeyAndVersion)
        var secondSHA = SHA256HexToByteArray(firstSHA)
        var checksum = secondSHA.substr(0, 8).toUpperCase()

        var keyWithChecksum = privateKeyAndVersion + checksum

        let bitcoinPrivateKey = Base58Encode(keyWithChecksum)

        return bitcoinPrivateKey;
    }

    function StringToHex(str)
    {
        var result = '';
        for (var i=0; i<str.length; i++) {
        result += str.charCodeAt(i).toString(16);
        }
        return result;
    }
    

    function BnToHex(bn) {
        var base = 16;
        var hex = BigInt(bn).toString(base);
        if (hex.length % 2) {
            hex = '0' + hex;
        }
        return hex;
    }

    function GenerateRandomPrivateKey()
    {
        var randArr = new Uint8Array(32) 
        window.crypto.getRandomValues(randArr)

        var privateKeyBytes = []
        for (var i = 0; i < randArr.length; ++i)
            privateKeyBytes[i] = randArr[i]

        var privateKeyHex = BytesToHex(privateKeyBytes).toUpperCase()

        var privateKeyAndVersion = "80" + privateKeyHex

        return _PrivateKeyAndVersionToBitcoinKey(privateKeyAndVersion);
    }

    function GenerateRandomCompressedPrivateKey()
    {
        let randomKey = GenerateRandomPrivateKey();
        let compressed = CompressWIF(randomKey)
        
        return compressed
    }

    function GeneratePrivateKeyFromNumber(numStr)
    {
        let num = BigInt(numStr)

        let privateKeyHex = _FormatHexStringLength(BnToHex(num))
        let privateKeyHexAndPrefix = "80" + privateKeyHex;

        return _PrivateKeyAndVersionToBitcoinKey(privateKeyHexAndPrefix);
    }

    function GenerateCompressedPrivateKeyFromNumber(numStr)
    {
        let num = BigInt(numStr)

        let privateKeyHex = _FormatHexStringLength(BnToHex(num))
        let privateKeyHexAndPrefix = "80" + privateKeyHex + "01";

        return _PrivateKeyAndVersionToBitcoinKey(privateKeyHexAndPrefix);
    }

    function GetNumberFromPrivateKey(key)
    {
        let formattedHex = _GetHexFromPrivateKey(key)
        
        return BigInt('0x'+formattedHex)
    }

    function DecompressWIF(compressedKey)
    {
        if (compressedKey.startsWith('5'))
            return compressedKey

        let formattedHex = _GetHexFromPrivateKey(compressedKey);
        formattedHex = formattedHex.substr(0, formattedHex.length -2)
        let k = "80" + formattedHex;
        return _PrivateKeyAndVersionToBitcoinKey(k);
    }

    function CompressWIF(key)
    {
        if (key.startsWith('L') || key.startsWith('K'))
            return key;

        let formattedHex = _GetHexFromPrivateKey(key)
        let k = "80" + formattedHex + "01"
        return _PrivateKeyAndVersionToBitcoinKey(k)
    }

    function PrivateKeyToLegacyAddress(privateKey)
    {
        let formattedHex = _GetHexFromPrivateKey(privateKey);

        let point = Point.fromPrivateKey(formattedHex);
        let xHex = BnToHex(point.x);
        let yHex = BnToHex(point.y);

        let concat = "04"+xHex+yHex;
        let sha256Result = SHA256HexToByteArray(concat);
        let ripemd160Result = RIPEMD160HexToByteArray(sha256Result)
        
        let publicKeyWithVersion = "00" + ripemd160Result;

        let checksum = SHA256HexToByteArray(SHA256HexToByteArray(publicKeyWithVersion)).substr(0,8)

        let publicKeyWithChecksum = publicKeyWithVersion + checksum
        return (Base58Encode(publicKeyWithChecksum))
    }

    function CompressedPrivateKeyToLegacyAddress(key)
    {
        let formattedHex = _GetHexFromPrivateKey(key)
        formattedHex = formattedHex.substr(0, formattedHex.length - 2)
        
        console.log(formattedHex)

        let point = Point.fromPrivateKey(formattedHex);
        let xHex = BnToHex(point.x);
        let yHex = BnToHex(point.y);

        if (point.y % BigInt('2') == BigInt('0'))
        {
            xHex = "02" + xHex;
        }
        else
        {
            xHex = "03" + xHex
        }

        let sha256Result = SHA256HexToByteArray(xHex);
        let ripemd160Result = RIPEMD160HexToByteArray(sha256Result);

        let publicKeyWithVersion = "00" + ripemd160Result;

        let checksum = SHA256HexToByteArray(SHA256HexToByteArray(publicKeyWithVersion)).substr(0,8)
    
        let publicKeyWithChecksum = publicKeyWithVersion + checksum;

        return (Base58Encode(publicKeyWithChecksum));
    }

    function CompressedPrivateKeyToSegwitAddress(key)
    {
        let formattedHex = _GetHexFromPrivateKey(key.substr(0, key.length-2));

        let point = Point.fromPrivateKey(formattedHex);
        let xHex = BnToHex(point.x);
        let yHex = BnToHex(point.y);

        if (point.y % BigInt('2') == BigInt('0'))
        {
            xHex = "02" + xHex;
        }
        else
        {
            xHex = "03" + xHex
        }

        let sha256Result = SHA256HexToByteArray(xHex);
        let scriptHash = RIPEMD160HexToByteArray(sha256Result);

        let p2sh_p2wpkh_v0 = HexToBytes("a9"+scriptHash+'87')
        let flaggedScriptHash = HexToBytes("06"+scriptHash)

        let checksum = SHA256HexToByteArray(SHA256HexToByteArray(BytesToHex(flaggedScriptHash))).substr(0,8)

        let binAddr = BytesToHex(flaggedScriptHash) + checksum
        
        console.log(Base58Encode(binAddr))
    }

    function PrivateKeyToBech32Address(key)
    {
        let hashResult = _HashPrivateKey(key)
    }
</script>

<script>
    let compr = 'KzMVzFdD4UDzRiXpGUtmM9HDh8RefUR4ZrQk53Qh6USTs7kDxxFS'
    console.log(compr)
    let decomp = DecompressWIF(compr)
    let legacy = PrivateKeyToLegacyAddress(decomp)
    let legacyc = CompressedPrivateKeyToLegacyAddress(compr)
    console.log(legacyc)
    console.log(legacy)
</script>