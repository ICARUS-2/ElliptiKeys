<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
    const HEX_LENGTH = 64;
    const MAX_PRIVATE_KEY = BigInt("115792089237316195423570985008687907852837564279074904382605163141518161494336")

    function SHA256HexToByteArray(a)
    {
        return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(a)).toString()
    }

    function BytesToHex(byteArray) {
        return Array.from(byteArray, function(byte) 
        {
            return ('0' + (byte & 0xFF).toString(16)).slice(-2);
        }).join('')
    }

    function HexToBytes(hexString) {
    if (hexString.length % 2 !== 0) {
        throw "Must have an even number of hex digits to convert to bytes";
    }/* w w w.  jav  a2 s .  c o  m*/
    var numBytes = hexString.length / 2;
    var byteArray = new Uint8Array(numBytes);
    for (var i=0; i<numBytes; i++) {
        byteArray[i] = parseInt(hexString.substr(i*2, 2), 16);
    }
    return byteArray;
}

    function Base58Encode(hex_number) {
    const base58 = [1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
    var num = BigInt('0x' + hex_number);
    const fifty8 = BigInt(58);
    var remainder;
    var b58_encoded_buffer = '';
    while (num > 0) {
        remainder = num % fifty8;
        b58_encoded_buffer = base58[remainder] + b58_encoded_buffer;
        num = num/BigInt(58);
    }
    while ( hex_number.match(/^00/) ){
        b58_encoded_buffer = '1' + b58_encoded_buffer;
        hex_number = hex_number.substring(2);
    }
    return b58_encoded_buffer;
}

    function Base58Decode(input)
    {

    }

    function _FormatHexStringLength(s)
    {
        if (s.length == HEX_LENGTH)
            return s

        let trailingZeroes = '';
        let diff = HEX_LENGTH - s.length;

        while (trailingZeroes.length < diff)
        {
            trailingZeroes += '0';
        }
        
        return trailingZeroes + s;
    }

    function BnToHex(bn) {
        var base = 16;
        var hex = BigInt(bn).toString(base);
        if (hex.length % 2) {
            hex = '0' + hex;
        }
        return hex;
    }

    function GeneratePrivateKeyFromNumber(numStr)
    {
        let num = BigInt(numStr)

        let privateKeyHex = _FormatHexStringLength(BnToHex(num))

        let privateKeyHexAndPrefix = "80" + privateKeyHex;

        let firstSha256 = SHA256HexToByteArray(privateKeyHexAndPrefix);
        let secondSha256 = SHA256HexToByteArray(firstSha256);
        var checksum = secondSha256.substr(0, 8).toUpperCase()

        let bitcoinPrivateKey = Base58Encode(privateKeyHexAndPrefix+checksum)
        console.log(privateKeyHexAndPrefix+checksum)
        return bitcoinPrivateKey;
    }

    function GetNumberFromPrivateKey(key)
    {

    }
</script>

<script>
    let key = GeneratePrivateKeyFromNumber(MAX_PRIVATE_KEY-BigInt('1'))

    console.log(key)
</script>